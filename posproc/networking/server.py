from posproc.networking.node import Node
from posproc.networking.user_data import UserData
from posproc import constants
import threading
from posproc.key import Key
from posproc.error_correction.cascade.block import Block
import pickle
"""
This module contains code for active client who is going to be doing all the computation.
In theory we consider bob to be the active client who asks question to alice about parity
and Alice is an passive client who is just going to reply to all the questions that bob
asks.
"""


class Server(Node):
    """
    Creates the Server (Alice's) socket.

    """
    def __init__(self, username,correct_key:Key, user_data:UserData = None,server_type=constants.LOCAL_SERVER, port=constants.LOCAL_PORT):
        """
        Alice's key is needed for performing computation.
        This Node will only run on Alice's address so only she knows the correct key.
        
        Args:
            correct_key (Key): Alice's Key Obtained from the QKD protocol.
            user_data (UserData): The object that will store all the data about users on the network.
            server_type (str, optional): [Either LOCAL_SERVER or PUBLIC_SERVER {defined in constants.py}]. Defaults to LOCAL_SERVER.
            port (int, optional): [The local port to be used for hosting the server. Defaults to LOCAL_PORT]. Defaults to LOCAL_PORT.
        """
        super().__init__(username)
        #This is the correct_key i.e. the Key that Alice has.
        self.__correct_key = correct_key
        
        
        #Clients that are currently connected to Alice's Server
        #this dict contains key as username and value as the public id generated by ecdsa module
        self.active_clients = {}
        
        #userdata, an instance of UserData contains the data of all clients connected to Alice (SERVER)
        self.user_data = user_data

        self.server_type = server_type
        self.port = port

        self.address = None
        self._set_the_address_variable()

        # The Server will start on this address
        self.LOCAL_ADDRESS = (constants.LOCAL_IP, constants.LOCAL_PORT)
        # Then we can port-forward the ngrok address to this address

        self.start_listening()

        # Now Start accepting connections:
        self.start_receiving()

    def get_address(self):
        """
        Returns the current address either local or public

        Returns:
            server_address [tuple]: In the form (IP,PORT)
        """
        return self.address
    
    def _set_the_address_variable(self):
        if self.server_type == constants.LOCAL_SERVER:
            self.address = (constants.LOCAL_IP, self.port)
        if self.server_type == constants.PUBLIC_SERVER:
            self.address = self.start_ngrok_tunnel(self.port)
        

    def start_listening(self):
        print(f"[STARTING] {self.server_type} server is starting...")
        self.bind(self.LOCAL_ADDRESS)
        self.listen(1)
        print(f"[LISTENING] Server is listening @ {self.get_address()}")

    def handle_client(self, client, address):
        connected = True
        while connected:
            msg_received = self.receive_a_message_from_client(client)
            if msg_received:
                if msg_received.startswith("ask_parities".encode(constants.FORMAT)):
                    msg_to_send = self._ask_parities_return_message(msg_received)
                    self.send_a_message_to_the_client(client, msg_to_send)
                else:
                    print(f"[Client @ {address}]: {msg_received}")

    def _ask_parities_return_message(self,msg_recvd):
        #message_recvd = b'ask_parities:[block_indexes as list,[],[],...]'
        splitted_msg_recvd = msg_recvd.split(":".encode(constants.FORMAT))
        blocks_indexes = pickle.loads(splitted_msg_recvd[-1])
        parities = []
        
        #TODO: Store the information leaked into some new class to help in privacy amplification.
        
        for block_indexes in blocks_indexes:
            parity = self.__correct_key.get_indexes_parity(block_indexes)
            parities.append(parity)
        msg_to_send = b'ask_parities:' + pickle.dumps(parities)
        return msg_to_send
    
    def start_receiving(self):
        while True:
            client, addr = self.accept()
            
            print(f"Connected with {addr}")

            thread = threading.Thread(
                target=self.handle_client, args=(client, addr))
            thread.start()
            print(
                f"[ACTIVE CONNECTIONS]: {threading.active_count() - 1} clients are connected!")

    def stop_server(self):
        #TODO: Make it work!
        pass

    def broadcast_to_all(self, message):
        #TODO: Try this out!
        for client in self.clients:
            thread = threading.Thread(
                target=self.send_a_message_to_the_client, args=())
            self.send_a_message_to_the_client(client,message)

 

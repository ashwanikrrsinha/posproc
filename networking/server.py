from networking.node import Node
from networking.user_data import UserData
import constants
from pyngrok import ngrok
import threading
from key import Key
#from error_correction.cascade.block import Block

"""
This module contains code for active client who is going to be doing all the computation.
In theory we consider bob to be the active client who asks question to alice about parity
and Alice is an passive client who is just going to reply to all the questions that bob
asks.
"""

def parity_of_indexes(raw_key, indexes):
    #TODO: Include this method in the PassiveClient Class.
    s = 0
    for i in indexes:
        s += raw_key[i]
    return s % 2


class Server(Node):
    """
    Creates the Server (Alice's) socket.

    """
    def __init__(self, correct_key:Key, user_data:UserData,server_type=constants.LOCAL_SERVER, port=constants.LOCAL_PORT):
        """
        Alice's key is needed for performing computation.
        This Node will only run on Alice's address so only she knows the correct key.
        
        Args:
            correct_key (Key): Alice's Key Obtained from the QKD protocol.
            server_type (str, optional): [Either LOCAL_SERVER or PUBLIC_SERVER {defined in constants.py}]. Defaults to LOCAL_SERVER.
            port (int, optional): [The local port to be used for hosting the server. Defaults to LOCAL_PORT]. Defaults to LOCAL_PORT.
        """
        super().__init__()
        
        #This is the correct_key i.e. the Key that Alice has.
        self.__correct_key = correct_key
        
        #Clients that are currently connected to Alice's Server
        #this dict contains key as username and value as the public id generated by eccdsa module
        self.active_clients = {}
        self.user_data = user_data

        self.server_type = server_type
        self.port = port

        self.address = None
        self._set_the_address_variable()

        # The Server will start on this address
        self.LOCAL_ADDRESS = (constants.LOCAL_IP, constants.LOCAL_PORT)
        # Then we can port-forward the ngrok address to this address

        self.start_listening()

        # Now Start accepting connections:
        self.start_receiving()

    def get_address(self):
        """
        Returns the current address either local or public

        Returns:
            server_address [tuple]: In the form (IP,PORT)
        """
        return self.address
    
    def _set_the_address_variable(self):
        if self.server_type == constants.LOCAL_SERVER:
            self.address = (constants.LOCAL_IP, self.port)
        if self.server_type == constants.PUBLIC_SERVER:
            self.address = self.start_ngrok_tunnel(self.port)
        

    def start_listening(self):
        print(f"[STARTING] {self.server_type} server is starting...")
        self.bind(self.LOCAL_ADDRESS)
        self.listen(1)
        print(f"[LISTENING] Server is listening @ {self.get_address()}")

    def handle_client(self, client, address):
        connected = True
        while connected:
            msg_received = self.receive_a_message_from_client(client)
            if msg_received:
                print(f"[Client @ {address}]: {msg_received}")
                if msg_received.startswith("ask_parity"):
                    msg_to_send = self.ask_parity_return_message(msg_received)
                    self.send_a_message_to_the_client(client, msg_to_send)

    def ask_parity_return_message(self, msg_received: str):
        splitted_parity_msg = msg_received.split(":")
        msg_no = int(splitted_parity_msg[1])
        indexes_o = splitted_parity_msg[2].split(",")
        indexes = []
        for i in indexes_o:
            indexes.append(int(i))
        #indexes contains the indexes of bits to calculate parities!
        # Assuming Alice is the instance of this Server Class
        parity = parity_of_indexes(self.alices_key, indexes)
        msg_to_send = f"ask_parity:{msg_no}:{parity}"
        return msg_to_send

    def start_receiving(self):
        while True:
            client, addr = self.accept()
            
            print(f"Connected with {addr}")

            thread = threading.Thread(
                target=self.handle_client, args=(client, addr))
            thread.start()
            print(
                f"[ACTIVE CONNECTIONS]: {threading.active_count() - 1} clients are connected!")
            #self.handle_client(client,addr)

    def stop_server(self):
        #TODO: Make it work!
        pass

    def broadcast_to_all(self, message):
        #TODO: Try this out!
        for client in self.clients:
            thread = threading.Thread(
                target=self.send_a_message_to_the_client, args=())
            self.send_a_message_to_the_client(client,message)

 
